<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[张弦的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhangxian.me/"/>
  <updated>2014-10-18T09:18:53.301Z</updated>
  <id>http://zhangxian.me/</id>
  
  <author>
    <name><![CDATA[xuangong]]></name>
    <email><![CDATA[zhangxian1124@bupt.edu.cn]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[模拟smtp协议]]></title>
    <link href="http://zhangxian.me/2014/07/09/simulate-smtp/"/>
    <id>http://zhangxian.me/2014/07/09/simulate-smtp/</id>
    <published>2014-07-09T02:41:19.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>动手写邮件发送的程序之前，第一步让我们来模拟一下smtp协议的过程来发送一份邮件。</p>
<p>下面简单演示一下如何用telnet来模拟smtp协议发送一份邮件</p>
<ol>
<li>找到一个可用的smtp server的ip地址，当前我得到的163邮箱的smtp server的ip地址是220.181.12.16</li>
<li>telnet和smtp server的25端口建立tcp连接，<code>telnet 220.181.12.16 25</code>，收到的回应是&quot;220 163.com Anti-spam GT for Coremail System (163com[20121016])&quot;</li>
<li>发送<code>HELO 220.181.12.16</code>，收到回应&quot;250 OK&quot;</li>
<li>请求登录，发送<code>auth login</code>，收到回应“334 dXNlcm5hbWU6”，后面那串字母是被base64加密后的内容，解密后的实际内容是：&quot;username:&quot;</li>
<li>发送自己163邮箱的用户名base64加密后的内容，比如我的email地址是&quot;zhang_xian_freedom@163.com&quot;，我的username就是&quot;zhang_xian_freedom&quot;，所以我发送的内容是：<code>emhhbmdfeGlhbl9mcmVlZG9t</code>。收到回应：334 UGFzc3dvcmQ6&quot;，解密后的实际内容是：&quot;Password:&quot;</li>
<li>发送自己用户名对应的密码用base64加密后的内容，收到回应：&quot;235 Authentication successful&quot;。到此，跟mail server身份验证的工作已经结束。</li>
<li>跟smpt服务器指定邮件的来处：<code>mail from:&lt;zhang_xian_freedom@163.com&gt;</code>，收到回应：&quot;250 Mail OK&quot;</li>
<li>跟smpt服务器指定要发送的邮件去处：<code>rcpt to:&lt;zhangxian1124@bupt.edu.cn&gt;</code>，收到回应：&quot;250 Mail OK&quot;</li>
<li>发送邮件正文内容标识：<code>data</code>，收到回应：<code>354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code></li>
<li>邮件中显示的发给谁：<code>to:zhangxian1124@bupt.edu.cn</code>和<code>subject:Test Mail</code></li>
<li>发送一个空行，然后发送邮件正文<code>This is a test mail...</code></li>
<li>发送<code>.</code>标识结束<a id="more"></a>

</li>
</ol>
<p><img src="/images/20140709.smtp.simulate.png" alt="命令行交互过程"></p>
<p><img src="/images/20140709.mail.list.png" alt="邮件"></p>
<p>BTW，mac中善用alfred的workflow，我用<a href="https://github.com/BigLuck/alfred2-hash" target="_blank">Hash calculator</a>可以很方便的做Base64 Encode和Base64 Decode。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>动手写邮件发送的程序之前，第一步让我们来模拟一下smtp协议的过程来发送一份邮件。</p>
<p>下面简单演示一下如何用telnet来模拟smtp协议发送一份邮件</p>
<ol>
<li>找到一个可用的smtp server的ip地址，当前我得到的163邮箱的smtp server的ip地址是220.181.12.16</li>
<li>telnet和smtp server的25端口建立tcp连接，<code>telnet 220.181.12.16 25</code>，收到的回应是&quot;220 163.com Anti-spam GT for Coremail System (163com[20121016])&quot;</li>
<li>发送<code>HELO 220.181.12.16</code>，收到回应&quot;250 OK&quot;</li>
<li>请求登录，发送<code>auth login</code>，收到回应“334 dXNlcm5hbWU6”，后面那串字母是被base64加密后的内容，解密后的实际内容是：&quot;username:&quot;</li>
<li>发送自己163邮箱的用户名base64加密后的内容，比如我的email地址是&quot;zhang_xian_freedom@163.com&quot;，我的username就是&quot;zhang_xian_freedom&quot;，所以我发送的内容是：<code>emhhbmdfeGlhbl9mcmVlZG9t</code>。收到回应：334 UGFzc3dvcmQ6&quot;，解密后的实际内容是：&quot;Password:&quot;</li>
<li>发送自己用户名对应的密码用base64加密后的内容，收到回应：&quot;235 Authentication successful&quot;。到此，跟mail server身份验证的工作已经结束。</li>
<li>跟smpt服务器指定邮件的来处：<code>mail from:&lt;zhang_xian_freedom@163.com&gt;</code>，收到回应：&quot;250 Mail OK&quot;</li>
<li>跟smpt服务器指定要发送的邮件去处：<code>rcpt to:&lt;zhangxian1124@bupt.edu.cn&gt;</code>，收到回应：&quot;250 Mail OK&quot;</li>
<li>发送邮件正文内容标识：<code>data</code>，收到回应：<code>354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code></li>
<li>邮件中显示的发给谁：<code>to:zhangxian1124@bupt.edu.cn</code>和<code>subject:Test Mail</code></li>
<li>发送一个空行，然后发送邮件正文<code>This is a test mail...</code></li>
<li>发送<code>.</code>标识结束]]>
    
    </summary>
    
      <category term="protocol" scheme="http://zhangxian.me/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解跳跃表skiplist]]></title>
    <link href="http://zhangxian.me/2014/07/01/skiplist/"/>
    <id>http://zhangxian.me/2014/07/01/skiplist/</id>
    <published>2014-06-30T16:53:43.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>跳跃表是一种随机化数据结构，基于<strong>并联的链表</strong>，其效率可以逼近二叉查找树，对于大多数操作需要O(logn)平均时间，并且对<strong>并发</strong>算法友好。
跳跃表对<strong>有序</strong>链表增加附加的前进链接，增加（Insert）是以随机化的方式进行的，所以可以快速的跳过部分列表，故以此得名。
她是很年轻的算法而且实现简单，深受广大程序员喜爱。</p>
</blockquote>
<p>需要动态维护数据，有对数复杂度的插入、删除和查找性能，可以选择的数据结构很多，比如：</p>
<ul>
<li>B-tree</li>
<li>Red-black tree</li>
<li>treap</li>
</ul>
<p>如果要求一个小时完成程序，竟然还不给我们翻书，那咱们选择谁呢？OK，答案是我们今天的主人公：跳跃表skiplist</p>
<p>跳跃表按层构造的，让我们看一下redis中跳跃表的数据结构(<a href="http://github.com/antirez/redis/blob/unstable/src/redis.h" target="_blank">redis.h</a>)：
<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/*
 * 跳跃表
 */</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist {
    <span class="comment">// 头节点，尾节点</span>
    <span class="keyword">struct</span> zskiplistNode *header, *tail;
    <span class="comment">// 节点数量</span>
    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;
    <span class="comment">// 目前表内节点的最大层数</span>
    <span class="keyword">int</span> level;
} zskiplist;
</pre></td></tr></table></figure>



<p>而zskiplistNode的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">/* ZSETs use a specialized version of Skiplists */</span>
<span class="comment">/*
 * 跳跃表节点
 */</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode {
    <span class="comment">// member 对象</span>
    robj *obj;
    <span class="comment">// 分值</span>
    <span class="keyword">double</span> score;
    <span class="comment">// 后退指针</span>
    <span class="keyword">struct</span> zskiplistNode *backward;
    <span class="comment">// 层</span>
    <span class="keyword">struct</span> zskiplistLevel {
        <span class="comment">// 前进指针</span>
        <span class="keyword">struct</span> zskiplistNode *forward;
        <span class="comment">// 这个层跨越的节点数量</span>
        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;
    } level[];
} zskiplistNode;
</pre></td></tr></table></figure>


<p>zslCreate的时候tail直接为空，但是header是需要被创建并初始化为空的。数据结构中需要理解清楚的是span的含义，每个zskiplistNode的不同zskiplistLevel都有其独立的span，标识在这一层上，从该节点跳跃到下一个节点的步长:</p>
<ul>
<li>同一层的不同节点包含的span可以不同</li>
<li>新增一层时span直接初始化为跳表的长度</li>
</ul>
<p>Insert数据时，先给每一层定位插入节点的位置(从高层到低层查找)</p>
<p>跳跃表插入结构如图</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/xuqiang/algorithm/skiplist_delete.png" alt="skiplist" title="insert-skiplist"></p>
<p>核心代码逻辑如下所示(<a href="https://github.com/antirez/redis/blob/unstable/src/t_zset.c" target="_blank">t_zset.c</a>)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>    x = zsl-&gt;header;
    <span class="comment">// 记录沿途访问的节点，并计数 span 等属性</span>
    <span class="comment">// 平均 O(log N) ，最坏 O(N)</span>
    <span class="keyword">for</span> (i = zsl-&gt;level-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
        <span class="comment">/* store rank that is crossed to reach the insert position */</span>
        rank[i] = i == (zsl-&gt;level-<span class="number">1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];

        <span class="comment">// 右节点不为空</span>
        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;
            <span class="comment">// 右节点的 score 比给定 score 小</span>
            (x-&gt;level[i].forward-&gt;score &lt; score ||
                <span class="comment">// 右节点的 score 相同，但节点的 member 比输入 member 要小</span>
                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) {
            <span class="comment">// 记录跨越了多少个元素</span>
            rank[i] += x-&gt;level[i].span;
            <span class="comment">// 继续向右前进</span>
            x = x-&gt;level[i].forward;
        }
        <span class="comment">// 保存访问节点</span>
        update[i] = x;
    }
</pre></td></tr></table></figure>


<p>先查找到最高层（最稀疏的层，直到发现右边元素比左边元素大时，记录该Node到update[level-1]），用保存节点的变量node x，定位x的下一层，继续查找。这样就可以用接近二叉查找树的性能找到各层需要插入位置的前邻近节点(第i层保存为update[i])，同时统计出各层预计插入位置前邻近节点已经跨越了多少个实际节点(逻辑上第0层的节点):rank[i]（从header后面真正的数据节点开始算）。</p>
<p>用很好的性能做好这样的准备工作以后，就开始真正的插入动作，插入时需要确定在哪一层插入，跳表采用的是随机化方法，插入在第i+1层的概率是出现在i层的1/p决定插入level的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">int</span> zslRandomLevel(<span class="keyword">void</span>) {
    <span class="keyword">int</span> level = <span class="number">1</span>;
    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))
        level += <span class="number">1</span>;
    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
</pre></td></tr></table></figure>

<p>需要明确的是，在跳表中，虽然节点的指针很多，但是数据本身不会保存多份（<strong>共享的是一份数据</strong>）
节点中上层level的span是计算出来的（准确的说是由底层的信息计算出来的），计算的方法如下：</p>
<ul>
<li>我们容易得到各层距离插入点最近的节点跨越了多少节点（从header后面真正的数据节点开始算），即rank[i]。</li>
<li>我们知道已存在节点各层span（即节点跳跃到右边一步实际跨越多少个节点）</li>
</ul>
<p>操作有三种情况，假设插入一个节点选择的层是level，操作过程分一下几类情况：</p>
<ol>
<li>(level，zsl-&gt;level] 范围内，插入操作是不影响结构的，只需要更新这范围内各层中距离插入几点最近的节点中span的数字: <code>update[i].level[i].span++</code></li>
<li>[0, level] 范围内，插入节点是影响结构的，span的计算是用<code>update[i].level[i].span - (rank[i] - rank[0] ) + 1</code></li>
<li>(zsl-&gt;level, level] 范围内，说明这些层还没有被建立起来，这个范围内的各层需要设置<code>rank[i] = 0</code>(看作从header降层下来的)更新<code>update[i].span = zsl-&gt;length</code>同时 更新 <code>zsl-&gt;level = level</code>，范围就转化成了第2中情况</li>
</ol>
<p>理解跳跃表的核心部分就说完了，捋清楚插入的过程，查找和删除就非常容易了。Enjoy...</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>跳跃表是一种随机化数据结构，基于<strong>并联的链表</strong>，其效率可以逼近二叉查找树，对于大多数操作需要O(logn)平均时间，并且对<strong>并发</strong>算法友好。
跳跃表对<strong>有序</strong>链表增加附加的前进链接，增加（Insert）是以随机化的方式进行的，所以可以快速的跳过部分列表，故以此得名。
她是很年轻的算法而且实现简单，深受广大程序员喜爱。</p>
</blockquote>
<p>需要动态维护数据，有对数复杂度的插入、删除和查找性能，可以选择的数据结构很多，比如：</p>
<ul>
<li>B-tree</li>
<li>Red-black tree</li>
<li>treap</li>
</ul>
<p>如果要求一个小时完成程序，竟然还不给我们翻书，那咱们选择谁呢？OK，答案是我们今天的主人公：跳跃表skiplist</p>
<p>跳跃表按层构造的，让我们看一下redis中跳跃表的数据结构(<a href="http://github.com/antirez/redis/blob/unstable/src/redis.h" target="_blank">redis.h</a>)：
]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxian.me/tags/algorithm/"/>
    
      <category term="data structure" scheme="http://zhangxian.me/tags/data%20structure/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由一道寻找唯一数字的题想到的]]></title>
    <link href="http://zhangxian.me/2014/06/28/find-the-special-num/"/>
    <id>http://zhangxian.me/2014/06/28/find-the-special-num/</id>
    <published>2014-06-27T17:43:59.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近本科室友发消息来问了一道题，引发了我一连串的好奇心。</p>
<p>P.S. 据师兄说这类问题貌似某书上有说过，可是已经不记得了，汗。。只怪肚子里的墨水太少，事实证明我这种庸人就应该事儿多^_^！</p>
<h3 id="1-">1.有很多数字，其中两两一样，只有一个数字不同，找出这个数字？</h3>
<hr>
<p>可以把让每个数字按位异或，最后得到的就是那个数字，这个是很基础的想法。时间复杂度O(n)，空间是O(1)，not bad.
扩展**
2.如果有两个数字是唯一的，怎么找出这两个数字？</p>
<hr>
<p>处理两遍，第一遍先按位异或，最后肯定得到的是一个不为零的数字，然后按照一个不为零的bit来划分所有的整数，得到两个集合，每个集合都符合<strong>第1题</strong>的情况，分别对两个集合处理，就能找到这两个数字。
继续扩展**
<a id="more"></a>
3.如果有三个数字是唯一的，怎么找出这三个数字？</p>
<p>OK，这个问题还是要转换到之前的问题上去，和第2问一样，我们怎么样才能把这三个数字给分开。
这三个数字是唯一的，其他的数字都是配对的，那我们还是按bit来分类呗。<strong>第2题</strong>先全部异或一遍，来精确找到各个唯一数字之间的差别的方法已经不好用了。（因为三个互异的数字异或完全可以等于0，又不能不异或，要不其他的配对数字就会产生<code>不想要</code>的贡献）
既然不能精确的知道这些唯一的数字到底那地方不通，那就暴力一点吧，咱们就假设可以按照一位来分割，比如<code>the first bit</code>，按照这一位来划分集合，只有两种情况，这三个数字被分割成两个集合，各个集合中包含目标数字个数总共就这么几种情况：<code>1|2、2|1、0|3、3|0</code>。我们需要统计分成的两组的数字个数。</p>
<p>如果分成1个和2个，到此成功把问题转化成了第2问和第1问，O(n)解决战斗。</p>
<p>如果分成0个和3个就讨厌了，问题并没有解决，甚至问题规模都不一定会减小。
咱们怎么来区分出这两种情况呢，不管集合中有1个还是2个<strong>目标数字</strong>，集合中元素异或起来都绝对非0。既然有0个<strong>目标数字</strong>的集合异或必然是0，异或可以解决问题。为了减少计算量，可以在分组的时候提前统计集合元素的数目，对大小为偶数的集合进行异或（为0就是含<strong>目标数字</strong>0个，非0就是含<strong>目标数字</strong>2个），奇数个的元素就自生自灭不管它。</p>
<p>现在我们成功的解决了第一种情况，事情进展的比预想的好一些，0个和3个<strong>目标数字</strong>咋办？问题规模还不一定减少，这。。。
想到这里，需要去喝点东西，45度角仰望天空看看天台上的意大利球迷。终于发现，问题卡壳是思维定势了。</p>
<p>虽然乍看下来，按一位分组，可能问题规模没有减小(分成0个和3个的情况)。。可是题目中说的是3个<strong>目标数字</strong>互异，也就是说不可能每一位都把3个<strong>目标数字</strong>都分到一边，只要把32位都按上面的方法分组过一遍，一定能把<strong>目标数字</strong>分成1个和2个的分组情况。这个复杂度可不是n方，数字的位数是定长的，最多也就32n，问题到此算是圆满解决了。</p>
<p>P.S. 这种方法我并不能推广到更多的目标数字去，如果你有更好的更通用的方法，请留言或者email告知我，邮箱在文章末尾</p>
<p><strong>往另一个方向上扩展</strong></p>
<h3 id="4-">4.如果数字都是三个一组相同，只有一个数字唯一，应该怎么找出这个数字？</h3>
<p>可以统计所有集合中每一位的出现情况，是三的倍数的就不管了，不是三的倍数的就是从<strong>目标数字</strong>中来的，这样用int variable[32]来计数就可以了，这样写没问题。</p>
<p>这个问题其实可以联系到前3个题目上，让我们进一步来寻找这个问题的不变式，联想第1个问题，两两相同的时候，可以按位异或。按位异或就是针对每个bit相同为0，不同为1，用一个整数来记录异或的结果，就是记录每个bit的状态转移，一个bit只要出现的次数是2的倍数就得是0，否则是1，最后就求解成功。</p>
<p>现在的问题是三个一组相同，其实就是每一个bit出现的次数是3的整数倍，就应该是0。很清楚了，尼玛可以想办法来记录0-1-2-0的状态转移啊...怎么表示这个状态转移呢，只需要两位就能表示三个状态了(这里可以扩展)，<strong>bingo</strong></p>
<p>我们设置两个整数a和b，其中a和b的第n个bit(共2个bit)就代表了集合中数字第n个bit出现1次数的状态情况(mod 3下:0-1-2-0)。这就是这个问题开头说的不变式，按位来看每一位的状态转移规则是完全相同的，就可以把这些需要处理的位搁在一起放好，组成整数一块计算(32bit)。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">//ones as a bitmask to represent the ith bit had appeared once.</span>
<span class="comment">//twos as a bitmask to represent the ith bit had appeared twice.</span>
<span class="comment">//threes as a bitmask to represent the ith bit had appeared three times.</span>
<span class="keyword">int</span> singleNumber(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) {
    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
        twos |= ones &amp; A[i];
        ones ^= A[i];
        threes = ones &amp; twos;
        ones &amp;= ~threes;
        twos &amp;= ~threes;
    }
    <span class="keyword">return</span> ones;
}
</pre></td></tr></table></figure>

<p>上面的代码中真正参加标识状态只需要两个变量，即ones和twos，其中threes是用来标记辅助置0状态的。
可以把这第三个变量优化掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">int</span> singleNumber(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)
{
    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)
    {
        ones = (ones ^ A[i]) &amp; ~twos;
        twos = (twos ^ A[i]) &amp; ~ones;
    }
    <span class="keyword">return</span> ones;
}
</pre></td></tr></table></figure>


<p><strong>P.S. 仅抛砖引玉，欢迎继续扩展讨论，欢迎发邮件到 <code>zhangxian1124@bupt.edu.cn</code> 告知我，十分感谢^_^！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近本科室友发消息来问了一道题，引发了我一连串的好奇心。</p>
<p>P.S. 据师兄说这类问题貌似某书上有说过，可是已经不记得了，汗。。只怪肚子里的墨水太少，事实证明我这种庸人就应该事儿多^_^！</p>
<h3 id="1-">1.有很多数字，其中两两一样，只有一个数字不同，找出这个数字？</h3>
<hr>
<p>可以把让每个数字按位异或，最后得到的就是那个数字，这个是很基础的想法。时间复杂度O(n)，空间是O(1)，not bad.
扩展**
2.如果有两个数字是唯一的，怎么找出这两个数字？</p>
<hr>
<p>处理两遍，第一遍先按位异或，最后肯定得到的是一个不为零的数字，然后按照一个不为零的bit来划分所有的整数，得到两个集合，每个集合都符合<strong>第1题</strong>的情况，分别对两个集合处理，就能找到这两个数字。
继续扩展**
]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxian.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Damn Line End Character]]></title>
    <link href="http://zhangxian.me/2014/05/31/damn-line-end-character/"/>
    <id>http://zhangxian.me/2014/05/31/damn-line-end-character/</id>
    <published>2014-05-30T18:28:15.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>这是在跨平台编辑代码的时候遇到的蛋疼问题。shell文件从dropbox同步到win上看一看再同步回mac，擦，执行的时候抽风了！</p>
<p>作为一个无知且不天真的低级码农，碰到这个诡异的问题不能忍，搞清楚了记一下。</p>
<p>vim认为win、unix和mac三大平台的换行符都不一样，分别是CRLF、LF和CR。尼玛，这个排列组合能再彻底一点吗？当然这个有历史原因，不过还是要说，尼玛！
<a id="more"></a></p>
<p>不知道为什么，用mac x10.9.3中自带的textEdit编辑以后，其实换行符都是按照unix的方式来的(这么做比较合理，不然cat一个文本什么都不输出，因为木有换行符啊！)，所以这两个平台应该统一了，<strong>我们这里说的是VIM怎么看</strong>。</p>
<p>CR显示出来是^M，而LF显示出来是^J。VIM在加载文件到缓冲区的时候，会对文本进行预处理，规则如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>如果all <span class="keyword">lines</span>的换行符是<span class="constant">CRLF</span>，则按照dos的规则处理，把<span class="constant">CRLF</span>都给处理成不可见字符后加载到缓冲区，当前buffer的ff变成dos。
如果有一行换行符是LF，则按照unix换行符的规则处理，把LF都处理成不可见字符后加载到缓冲区，当前buffer的ff变成unix。
这也是我们为什么把win下的文本放在linux中会有那么多的^M（顺便多句嘴，在vim中打出^M是ctrl-v ctrl-M）
</pre></td></tr></table></figure>

<p>强制让文本按照一种规则来加载到当前缓冲区可以<code>:e ++ff=dos[unix/mac]</code>，如果指定为mac，CF显示出来是另起一行显示^J</p>
<p>不可见字符变成了可见字符，就可以编辑了，正则匹配的时候，vim用<code>\r</code>可以把^M或者^J都匹配出来。</p>
<p>vim的默认fileformats=unix,dos，可以用<code>:set ffs</code>查看。如果是CRLF(format为dos)和LF共存的时候，会出现很多讨厌的^M，这个时候<code>:e ++ff=dos</code>后缓冲区的^M都不见了（不是真没了），然后<code>:setlocal ff=unix</code>再保存，于是保存的时候vim按照LF自动加上了换行符，nice！不改ff=unix直接保存是不行的，那样文本就不变了，记住默认的fileformats。</p>
<p>当然纯win下的文件把换行符改成LF，也可以这样干。</p>
<p>当然本来的format=dos，执行<code>:e ++f=unix</code>不可见字符^M显示出来以后，正则去处理，手动删除，随便你虐了。</p>
<p>到此，换行符这个蛋疼的问题算是讲清楚了，收工！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是在跨平台编辑代码的时候遇到的蛋疼问题。shell文件从dropbox同步到win上看一看再同步回mac，擦，执行的时候抽风了！</p>
<p>作为一个无知且不天真的低级码农，碰到这个诡异的问题不能忍，搞清楚了记一下。</p>
<p>vim认为win、unix和mac三大平台的换行符都不一样，分别是CRLF、LF和CR。尼玛，这个排列组合能再彻底一点吗？当然这个有历史原因，不过还是要说，尼玛！
]]>
    
    </summary>
    
      <category term="linux" scheme="http://zhangxian.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ucc中的奇技淫巧（持续更新）]]></title>
    <link href="http://zhangxian.me/2014/05/23/ucc%E4%B8%AD%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>http://zhangxian.me/2014/05/23/ucc中的奇技淫巧/</id>
    <published>2014-05-22T17:13:10.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-ucc-c98-naive-_-">对ucc——代码挺好看的一个c98编译器的naive记录...别瞎折腾，没什么用^_^</h2>
<h3 id="1-enum-">1.初始化寄存器变量的时候，寄存器是用enum类型来表示的:</h3>
<hr>
<p><code>enum { EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI };</code></p>
<p>申明数组大小的时候这么如：<code>Symbol X86Regs[EDI + 1];</code>这样以后要跟新这个列表，只要大小写保持是enum的最后一个就可以了。
<a id="more"></a></p>
<h3 id="2-">2.词法器的初始化：</h3>
<hr>
<p>搞了一个256大小的数组，存储函数指针，是为了直接把字符的ASCII码当成数组下标，256个下标对应的类型分成一下四类：</p>
<pre><code>- 语言中的符号` &#39; &quot; + - * / % &lt; &gt; = ! | &amp; ^ . { } ( ) [ ] , ; ~ ? : `加上`END_OF_FILE`
- 字母
- 数字
- 其它（不认识的字符，就可以抛出错误了）
</code></pre><p>注意：注意后面三类其实每一类的处理函数是一样的。第一类又可以分为两类：<code>{ } ( ) [ ] , ; ~ ? :</code>处理过程类似，移动读入指针和返回对应的token；其它的处理方式要单独写。</p>
<h3 id="3-">3.静态的组织表格的方法：</h3>
<hr>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">enum</span> token
{
  TK_BEGIN,
  <span class="preprocessor">#<span class="keyword">define</span> TOKEN(k, s) k,</span>
  <span class="preprocessor">#include "token.h"</span>
  <span class="preprocessor">#<span class="keyword">undef</span>  TOKEN</span>
};
</pre></td></tr></table></figure>

<p>token.h中截了三行，这样就可以想要取哪列都可以了，很清楚</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function">TOKEN(TK_VOLATILE,  <span class="string">"volatile"</span>)</span>
<span class="function">TOKEN(TK_SIGNED,    <span class="string">"signed"</span>)</span>
<span class="function">TOKEN(TK_UNSIGNED,  <span class="string">"unsigned"</span>)</span>
</pre></td></tr></table></figure>

<h3 id="4-linux-">4.在处理内存对齐的时候有一个宏很有意思，在linux中常见：</h3>
<hr>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>#define ALIGN(<span class="keyword">size</span>, <span class="keyword">align</span>) ((<span class="keyword">size</span> + <span class="keyword">align</span> - <span class="number">1</span>) & (~(<span class="keyword">align</span> - <span class="number">1</span>)))
</pre></td></tr></table></figure>

<p>记录一下这么搞的原理：<code>ALIGN(size, align)的得到的值，是size按照以align为倍数取上界</code></p>
<p>align如果值是8，则~(align-1)的值就是111...111000，这就是按照倍数取得上下界的关键，可称为对齐掩码。
先看这个式子</p>
<p><code>size &amp; ~(align-1)</code>表示的就是按照align的倍数取<code>下界</code>，这个很容易理解。再想怎么样才能定上界呢？其实有个非常容易想到的做法，就是加上align，但是这么做的bad case就是size本身就正好是align的倍数，这么做就错了，当然可以做判断修正这个bad case，同样也可以利用~(align-1)来修正，就得到了(size + size - 1) &amp; (~(align - 1))</p>
<h3 id="5-ucc-">5.这个技巧不是ucc中看到的，但是值得一说</h3>
<hr>
<ol>
<li><code>#define IS_POWER_OF_2(x) (!((x)&amp;((x)-1)))</code> 只有x是2的幂次的时候，这个表达式才是真</li>
<li>凑2的次幂取size的上界，代码和注释如下<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">/**
 * 把size调整到向上取到最近的2次幂
 * size |= size &gt;&gt; n;表示从低位到高位按2n位分组,每组内高n位复制到低n位
 * 最后经过处理size是从最高位的1开始往低位全1的整数
 * return size + 1; 得到向上凑够最近2次幂
 */</span>
<span class="keyword">static</span> <span class="keyword">unsigned</span> fixsize(<span class="keyword">unsigned</span> size) {
  size |= size &gt;&gt; <span class="number">1</span>;
  size |= size &gt;&gt; <span class="number">2</span>;
  size |= size &gt;&gt; <span class="number">4</span>;
  size |= size &gt;&gt; <span class="number">8</span>;
  size |= size &gt;&gt; <span class="number">16</span>;
  <span class="keyword">return</span> size+<span class="number">1</span>;
}
</pre></td></tr></table></figure>

</li>
</ol>
<h3 id="6-ucc-">6.ucc中内存的管理是维护了一个链表</h3>
<hr>
<p>这个模型非常简单，就是一个单向链表，链表记录了begin，end，avail三个指针，如果不够用了，就再申请大块的内存；够用了就直接从维护的堆上拿。
这样做的好处就是可以一直申请内存不释放，到最后一并把堆释放了就妥妥的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="-ucc-c98-naive-_-">对ucc——代码挺好看的一个c98编译器的naive记录...别瞎折腾，没什么用^_^</h2>
<h3 id="1-enum-">1.初始化寄存器变量的时候，寄存器是用enum类型来表示的:</h3>
<hr>
<p><code>enum { EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI };</code></p>
<p>申明数组大小的时候这么如：<code>Symbol X86Regs[EDI + 1];</code>这样以后要跟新这个列表，只要大小写保持是enum的最后一个就可以了。
]]>
    
    </summary>
    
      <category term="c" scheme="http://zhangxian.me/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常见的字符串Hash算法列举]]></title>
    <link href="http://zhangxian.me/2014/05/23/string%20hash%20methods/"/>
    <id>http://zhangxian.me/2014/05/23/string hash methods/</id>
    <published>2014-05-22T16:00:01.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>常见的字符串Hash算法如下，ucc中对符号表使用的是ELFHash，查了一下貌似不是效果非常好的hash算法。也列一列常用的hash算法以备不时之需。
<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
</pre></td><td class="code"><pre><span class="keyword">unsigned</span> <span class="keyword">int</span> SDBMHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;

    <span class="keyword">while</span> (*str)
    {
        <span class="comment">// equivalent to: hash = 65599*hash + (*str++);</span>
        hash = (*str++) + (hash &lt;&lt; <span class="number">6</span>) + (hash &lt;&lt; <span class="number">16</span>) - hash;
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// RS Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> RSHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">378551</span>;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">63689</span>;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;

    <span class="keyword">while</span> (*str)
    {
        hash = hash * a + (*str++);
        a *= b;
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// JS Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> JSHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">1315423911</span>;

    <span class="keyword">while</span> (*str)
    {
        hash ^= ((hash &lt;&lt; <span class="number">5</span>) + (*str++) + (hash &gt;&gt; <span class="number">2</span>));
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// P. J. Weinberger Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> PJWHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> BitsInUnignedInt = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * <span class="number">8</span>);
    <span class="keyword">unsigned</span> <span class="keyword">int</span> ThreeQuarters    = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((BitsInUnignedInt  * <span class="number">3</span>) / <span class="number">4</span>);
    <span class="keyword">unsigned</span> <span class="keyword">int</span> OneEighth        = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(BitsInUnignedInt / <span class="number">8</span>);
    <span class="keyword">unsigned</span> <span class="keyword">int</span> HighBits         = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0xFFFFFFFF</span>) &lt;&lt; (BitsInUnignedInt - OneEighth);
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash             = <span class="number">0</span>;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> test             = <span class="number">0</span>;

    <span class="keyword">while</span> (*str)
    {
        hash = (hash &lt;&lt; OneEighth) + (*str++);
        <span class="keyword">if</span> ((test = hash &amp; HighBits) != <span class="number">0</span>)
        {
            hash = ((hash ^ (test &gt;&gt; ThreeQuarters)) &amp; (~HighBits));
        }
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// ELF Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> ELFHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> x    = <span class="number">0</span>;

    <span class="keyword">while</span> (*str)
    {
        hash = (hash &lt;&lt; <span class="number">4</span>) + (*str++);
        <span class="keyword">if</span> ((x = hash &amp; <span class="number">0xF0000000</span>L) != <span class="number">0</span>)
        {
            hash ^= (x &gt;&gt; <span class="number">24</span>);
            hash &amp;= ~x;
        }
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// BKDR Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> BKDRHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;

    <span class="keyword">while</span> (*str)
    {
        hash = hash * seed + (*str++);
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// DJB Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> DJBHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;

    <span class="keyword">while</span> (*str)
    {
        hash += (hash &lt;&lt; <span class="number">5</span>) + (*str++);
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}

<span class="comment">// AP Hash Function</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> APHash(<span class="keyword">char</span> *str)
{
    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;
    <span class="keyword">int</span> i;

    <span class="keyword">for</span> (i=<span class="number">0</span>; *str; i++)
    {
        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)
        {
            hash ^= ((hash &lt;&lt; <span class="number">7</span>) ^ (*str++) ^ (hash &gt;&gt; <span class="number">3</span>));
        }
        <span class="keyword">else</span>
        {
            hash ^= (~((hash &lt;&lt; <span class="number">11</span>) ^ (*str++) ^ (hash &gt;&gt; <span class="number">5</span>)));
        }
    }

    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>常见的字符串Hash算法如下，ucc中对符号表使用的是ELFHash，查了一下貌似不是效果非常好的hash算法。也列一列常用的hash算法以备不时之需。
]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxian.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于动态规划（DP）的一点心得]]></title>
    <link href="http://zhangxian.me/2014/05/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_DP%E6%80%BB%E7%BB%93/"/>
    <id>http://zhangxian.me/2014/05/04/动态规划_DP总结/</id>
    <published>2014-05-03T16:16:35.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="-">概述：了解动态规划</h3>
<hr>
<p>动态规划算法一般都是基于一个递推公式和一组初始状态，当前子问题解将由上一次子问题的解推出，也就是传说中的（全局最优解包含局部最优解）一般用DP求解一个问题只需要多项式时间复杂度，因此要比回溯法和暴力求解法要快很多。</p>
<p>所以：我们需要求解一个状态的最优解，然后在它的帮助下找到下一个状态的最优解（注意这里是帮助，推出下一个状态的最优解，不一定依靠一个子问题的最优解，可能是一组状态的最优解进行筛选）
<a id="more"></a></p>
<h3 id="-">关键：如何找到”状态“和”递推公式“</h3>
<hr>
<p>所谓状态，即用来描述该问题子状态的解。状态转移方程-&gt;一些子问题的最优解推导出另一个规模更大的子问题的求解（状态转移方程这个词造的真好）</p>
<p>构造状态就成为了关键，怎么构造状态呢？</p>
<p>看一个典型的DP问题——0-1背包问题:</p>
<p>话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这哥们开始思考： 背包总共也就只能装下体积为C的东西，那我要装下哪些宝石才能让我获得最大的利益呢？</p>
<p>构造状态转移方程的关键在于，整个计算的规模是不断的减小的，现在我们的问题是找出把问题联系在一起的状态，要穷举出所有的状态。问题是要保证最后得到的价值是最大的，状态的值是-&gt;当前状态下的最大价值。</p>
<p>降低问题规模的方法来分析问题，我们在组合数学里已经非常熟悉了，先随便给宝石安排一个顺序，编号是1—n，求解的应该是i个宝石放在容量为n的袋子里面，按照最后一个编号为n的宝石的状态进行分类<code>（最后面那个n号宝石放在背包里|n号宝石不在背包里）</code>两种，不管怎么样，宝石的规模都会少1。OK，按照这个想法继续。因为我们每次都是按照最后一个宝石进行分类的，所以假设d(i, j)是前i个宝石放在容量剩余j的背包里，能获得的最大价值，假设i-1个宝石放在容量为n的背包里的最优解 和 i-1个宝石放在容量为j-[第n个宝石的体积]都已知。规模在减小，当然这种假设是成立的，初始条件是，0个宝石放在袋子里价值都是0。在i的规模不断减少的同时，j的规模也开始按照策略减少了，而所有的状态是可以枚举出来的。</p>
<p>状态转移方程是：<code>d(i, j)=max{ d(i-1, j), d(i-1,j-V[i-1]) + W[i-1] }</code>。
到此，状态表格和表格的填表规则已经规定完毕，剩下的就是按照规模从小到大的顺序开始填表了，要求的d(i, C)，只要确定d(i-1, 0)到d(i-1, C)的这组最优解即可......d(0, 0)到d(0, C)这一组是已知的。</p>
<h4 id="-">背包问题的代码如下：</h4>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include&lt;cstdio&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="preprocessor">#define MAXN 1000</span>
<span class="preprocessor">#define MAXC 100000</span>

<span class="keyword">int</span> V[MAXN], W[MAXN], x[MAXN];
<span class="keyword">int</span> d[MAXN][MAXC];

<span class="keyword">int</span> main(){
    freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, stdin);
    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, stdout);
    <span class="keyword">int</span> n, C;
    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;C) != EOF){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)   <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;V[i], &amp;W[i]);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)   x[i] = <span class="number">0</span>; <span class="comment">//初始化打印方案</span>

        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; ++i){
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=C; ++j){
                d[i][j] = i==<span class="number">0</span> ? <span class="number">0</span> : d[i-<span class="number">1</span>][j];
                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;=V[i-<span class="number">1</span>])  d[i][j] = d[i][j] &gt; d[i-<span class="number">1</span>][j-V[i-<span class="number">1</span>]]+W[i-<span class="number">1</span>] ? d[i][j] : d[i-<span class="number">1</span>][j-V[i-<span class="number">1</span>]]+W[i-<span class="number">1</span>];
            }
        }
        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[n][C]);

        <span class="comment">//输出打印方案</span>
        <span class="keyword">int</span> j = C;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;<span class="number">0</span>; --i){
            <span class="keyword">if</span>(d[i][j] &gt; d[i-<span class="number">1</span>][j]){
                x[i-<span class="number">1</span>] = <span class="number">1</span>;
                j = j - V[i-<span class="number">1</span>];
            }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)   <span class="built_in">printf</span>(<span class="string">"%d "</span>, x[i]);
        <span class="built_in">printf</span>(<span class="string">"\n"</span>);
    }
    fclose(stdin);
    fclose(stdout);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>



<h3 id="-">让我们 <strong>回顾</strong> 一下这道题的分析：</h3>
<hr>
<ol>
<li><p>考虑最优解的<strong><em>度量</em></strong>是“价值”-&gt;每个状态的值是价值。</p>
</li>
<li><p>考虑可以对最后一个宝石的最终的情况进行<strong><em>分类</em></strong>减少问题的规模，分类导致的是按照分类的情况得到各种情况下，较小规模的子问题和当前问题的联系，比如不同分类情况下子问题中价值和体积的情况是不同的，当前状态的最优解从小规模的最优解中推得。</p>
</li>
<li><p>背包价值的<strong><em>影响因素</em></strong>是“可选装包的宝石”，“背包的容量”。</p>
</li>
</ol>
<p>根据上面的分析，容易得出状态的转移建模d(i, j)表示前i个宝石装进容量为j的背包能得到的最大价值。计算规模是i*j的，比递归树要强太多了吧。
i和j都是可以枚举的，状态转移方程跟着就呼之欲出了。</p>
<p>怎么样，是不是和组合数学的分析方法非常非常类似呢，基本方法掌握以后，剩下的就是熟练运用了，本身的key在于分析，没有固定的模式，分析方法的总结非常重要，代码其实很好写（填表格还不容易）。</p>
<h2 id="update">update</h2>
<hr>
<p>我们再看两个例子,补充前文没有提到的情况：</p>
<h4 id="example1-">example1：求最长非降子序列</h4>
<p>比如“1，2，4，2，4&quot;的解应该是4。假设序列可以用d[i]表示，1——i个元素的序列，根据上面说的道理，可以取出最后一个数字来做分类，去掉最后一个数字的序列为d[i-1]，那么看出来d[i]和d[i-1]的关系，发现决定d[i]的大小不是靠着d[i-1]的大小，而是和d[k]（设k&lt;i）的最后一个元素与第i个元素之间的大小关系决定。可以得到状态转移方程应该表示成：d[i] = max{ 1, d[j] + 1} 其中j是小与i的集合，有了这个思路，程序就出来了。</p>
<p>去上面这个例子是想补充， 有时候得到当前状态的最优解可能需要比较的子状态局部最优解个数不是规定的，体现在代码中就是要多一个for循环。</p>
<h4 id="example2-">example2：求相同最长子序列</h4>
<p>再比如，上次校赛热身赛里面的一道题，给定一个整数序列，认为连续和隔一个数字都是连续的，求最长相同子序列的长度。</p>
<p>同样，用d[i]表示前i个数字的最长相同子序列长度，最后一个数字（第i个数字）做划分，状态转移方程为：</p>
<p><del>d[i] = (d[i-1] + 1 if x[i] == x[i-1] or x[i] == x[i-2]) or d[i-1] 初始条件为：单独考虑前两个数字d[0] = 1, 第二个根据情况取1 or 2</del></p>
<p><strong>划掉的部分是我的第一反应，却也是典型的错误。</strong></p>
<p><strong>改正</strong>:因为这个值的度量和0-1背包不同，是<code>和元素状态有关</code>的，所以最长子序列d[i]和d[i-1] or d[i-2]的关系其实应该由x[i-1]和x[i-2]与x[i]的关系来决定，状态转移方程应该依靠这个关系来确定，状态的表示含义就要换一种类型，<code>应该带上最后的元素信息</code>。正确的状态转移方程如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>d[i]表示前i个元素并且以x[i]结尾的序列。
d[i] = (d[i-<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> x[i] == x[i-<span class="number">1</span>] <span class="keyword">or</span> d[i-<span class="number">2</span>] + <span class="number">1</span> <span class="keyword">if</span> x[i] == x[i-<span class="number">2</span>]) <span class="keyword">or</span> <span class="number">1</span>
每次得到d[i]的时候要记录一次是不是长度达到了历史新高。（等价于判断最后得到的d[<span class="number">0</span>]—d[i]的最大值）
</pre></td></tr></table></figure>

<p>二维的情况，暂时先不讨论，有机会补充。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="-">概述：了解动态规划</h3>
<hr>
<p>动态规划算法一般都是基于一个递推公式和一组初始状态，当前子问题解将由上一次子问题的解推出，也就是传说中的（全局最优解包含局部最优解）一般用DP求解一个问题只需要多项式时间复杂度，因此要比回溯法和暴力求解法要快很多。</p>
<p>所以：我们需要求解一个状态的最优解，然后在它的帮助下找到下一个状态的最优解（注意这里是帮助，推出下一个状态的最优解，不一定依靠一个子问题的最优解，可能是一组状态的最优解进行筛选）
]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxian.me/tags/algorithm/"/>
    
      <category term="DP" scheme="http://zhangxian.me/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dijkstra Shortest Path]]></title>
    <link href="http://zhangxian.me/2014/05/03/dijkstra-shortest-path/"/>
    <id>http://zhangxian.me/2014/05/03/dijkstra-shortest-path/</id>
    <published>2014-05-02T16:20:35.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="-">五一要过去了，这个学期真是快</h3>
<hr>
<p>没回家，没出去玩儿，没什么要紧的事情要做，又比较懒，啥都不想干，闲的无聊，随手撸一个最短路径，好久没写过算法问题了，还得找一下数据结构的书来看一下。ok，合上书，整理一下思路，开始撸。。。</p>
<p>用邻接表和邻接矩阵都行，简单点就矩阵吧，我们假设就5个节点找一下单源最短路径问题。</p>
<p>想法非常简单，关键的地方就在于更新当前最短的距离，其实小心点很容易。</p>
<p>分析过程是：</p>
<ul>
<li><p>单步的增加搜索的范围，每次都能确定对一个点的最短路径，因为在当前步数范围内全局最短的那个节点，是不可能通过增加步数绕道缩短距离的。</p>
</li>
<li><p>每一步中，选出当前全局最短的节点加入S集合，表明该节点的最短路径已经找到。并且，更新各个节点的最短距离（更新时比较通过当前选出的节点到达的路径，因为考虑再扩大一步以后，固定下一个最短距离的路径肯定要是<code>节点本身到源点的直接路径或者通过已经在S集合中的点到达的路径</code>）</p>
<a id="more"></a>

</li>
</ul>
<h4 id="-">代码如下：</h4>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="code"><pre><span class="preprocessor">#ifndef _MY_DIJKSTRA_H</span>
<span class="preprocessor">#define _MY_DIJKSTRA_H</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="comment">//for the INT_MAX micro</span>
<span class="preprocessor">#include &lt;limits.h&gt;</span>

<span class="preprocessor">#define NUMVERTEX 5</span>
<span class="preprocessor">#define BOOL int</span>
<span class="preprocessor">#define TRUE 1</span>
<span class="preprocessor">#define FALSE 0</span>


<span class="comment">/*data struct*/</span>
<span class="comment">//map for path</span>
<span class="keyword">int</span> <span class="built_in">map</span> [][NUMVERTEX] = {
	{<span class="number">0</span>, <span class="number">10</span>, INT_MAX, INT_MAX, <span class="number">5</span>},
	{INT_MAX, <span class="number">0</span>, <span class="number">1</span>, INT_MAX, <span class="number">2</span>},
	{INT_MAX, INT_MAX, <span class="number">0</span>, <span class="number">4</span>, INT_MAX},
	{<span class="number">7</span>, INT_MAX, <span class="number">6</span>, <span class="number">0</span>, INT_MAX},
	{INT_MAX, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>},
};

<span class="comment">//record which node is already in S collection</span>
BOOL isInS[<span class="number">5</span>] = {FALSE};
<span class="comment">//record the currently shortest distence from startVetex to the i'th node in distence[i]</span>
<span class="keyword">int</span> distence[<span class="number">5</span>] = {<span class="number">0</span>};
<span class="comment">//record the index of node before the i'th node in pathpre[i]</span>
<span class="keyword">int</span> pathpre[<span class="number">5</span>];


<span class="comment">// c的二维数组是按行存储，线性排列的</span>
<span class="keyword">void</span> Dijkstra(<span class="keyword">const</span> <span class="keyword">int</span> numVertex, <span class="keyword">const</span> <span class="keyword">int</span> startVertex, <span class="keyword">int</span> <span class="built_in">map</span>[][<span class="number">5</span>])
{
	<span class="keyword">int</span> round = <span class="number">0</span>;
	<span class="keyword">int</span> preVertex = startVertex;
	<span class="comment">//init the pathpre array, assume startVetex is before a node when the distence between i'th node and startVetex is limited</span>
	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; ++i)
	{
		distence[i] = <span class="built_in">map</span>[startVertex][i];
		<span class="keyword">if</span> (<span class="built_in">map</span>[startVertex][i] &lt; INT_MAX)
			pathpre[i] = startVertex;
		<span class="keyword">else</span>
			pathpre[i] = -<span class="number">1</span>;
	}
	<span class="comment">//set a mark of startVetex</span>
	pathpre[startVertex] = -<span class="number">1</span>;

	<span class="comment">//startVertex is in the S collection at the very beginning</span>
	isInS[startVertex] = TRUE;

	<span class="comment">//need these many rounds to calculate the correct answer</span>
	<span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">0</span>; round &lt; numVertex - <span class="number">1</span>; ++round)
	{
		<span class="comment">//pick out whitch is the shortest path at present</span>
		<span class="keyword">int</span> tempDistence = INT_MAX;
		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; ++i)
		{
			<span class="keyword">if</span>(isInS[i] == FALSE &amp;&amp; distence[i] &lt; tempDistence)
			{
				tempDistence = distence[i];
				preVertex = i;
			}
		}

		<span class="comment">//set the selected one into S collection</span>
		isInS[preVertex] = TRUE;

		<span class="comment">//the other nodes out of S should update their states due to this selected one. Include distence and pathpre</span>
		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; ++i)
		{
			<span class="keyword">if</span> (isInS[i] == FALSE &amp;&amp; (<span class="built_in">map</span>[preVertex][i] &lt; INT_MAX) &amp;&amp; (<span class="built_in">map</span>[preVertex][i] + distence[preVertex] &lt; distence[i]))
			{
				distence[i] = <span class="built_in">map</span>[preVertex][i] + distence[preVertex];
				pathpre[i] = preVertex;
			}
		}
	}
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])
{
	Dijkstra(<span class="number">5</span>, <span class="number">0</span>, <span class="built_in">map</span>);
	<span class="comment">//need a buffer to build the correct path sequence</span>
	<span class="keyword">int</span> path[<span class="number">5</span>];
	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)
	{
		<span class="comment">//works just like a poor and low stack</span>
		<span class="keyword">int</span> idx = i;
		<span class="keyword">int</span> id = <span class="number">0</span>;
		<span class="keyword">do</span>
		{
			path[id] = idx;
			idx = pathpre[idx];
			id++;
		} <span class="keyword">while</span>(idx != -<span class="number">1</span>);

		<span class="built_in">printf</span>(<span class="string">"the %d to %d path is:"</span>, <span class="number">0</span>, i);
		<span class="keyword">for</span> (<span class="keyword">int</span> i = id- <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)
		{
			<span class="built_in">printf</span>(<span class="string">"%d  "</span>, path[i]);
		}
		<span class="comment">//end of poor and low stack</span>
		<span class="built_in">printf</span>(<span class="string">"length is %d\n"</span>, distence[i]);
	}

	<span class="keyword">return</span> <span class="number">0</span>;
}

<span class="preprocessor">#endif</span>
</pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h3 id="-">五一要过去了，这个学期真是快</h3>
<hr>
<p>没回家，没出去玩儿，没什么要紧的事情要做，又比较懒，啥都不想干，闲的无聊，随手撸一个最短路径，好久没写过算法问题了，还得找一下数据结构的书来看一下。ok，合上书，整理一下思路，开始撸。。。</p>
<p>用邻接表和邻接矩阵都行，简单点就矩阵吧，我们假设就5个节点找一下单源最短路径问题。</p>
<p>想法非常简单，关键的地方就在于更新当前最短的距离，其实小心点很容易。</p>
<p>分析过程是：</p>
<ul>
<li><p>单步的增加搜索的范围，每次都能确定对一个点的最短路径，因为在当前步数范围内全局最短的那个节点，是不可能通过增加步数绕道缩短距离的。</p>
</li>
<li><p>每一步中，选出当前全局最短的节点加入S集合，表明该节点的最短路径已经找到。并且，更新各个节点的最短距离（更新时比较通过当前选出的节点到达的路径，因为考虑再扩大一步以后，固定下一个最短距离的路径肯定要是<code>节点本身到源点的直接路径或者通过已经在S集合中的点到达的路径</code>）</p>
]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxian.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[总结&计划]]></title>
    <link href="http://zhangxian.me/2014/02/23/second-semester-plan/"/>
    <id>http://zhangxian.me/2014/02/23/second-semester-plan/</id>
    <published>2014-02-23T10:10:47.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">上学期总结和下学期规划一览</h2>
<h3 id="-">入学</h3>
<p>考研的分数不是太高，只能勉强过组线，所以提前不少时间就开始准备联系导师和准备复试了，基本上每个老师都发了简历，但是不是每个老师都回了。<del>感谢那些亲自回学生邮件并给出中肯建议的老师们，怀念方SIR回邮件的速度</del>
<a id="more"></a></p>
<p>我的第一次预面试，第一个见到的老师是L老师，见到L老师以后，他拿着我的简历，没问简历上面的项目经历和成绩，开始问我本科的专业<em>信息安全</em>有关的问题了，问我本科学了什么，懂了什么。这一下就问懵我了，我就实话实说呗，上了什么课，有很多没学会，很多只能涉及到基本的应用，很多停留在了解的层面上。他说学不会才正常(不明觉厉啊，哈哈)，问我如果要有充足的时间可以自由安排选课的话，觉得要学那些前序课程。最后印象比较深的，就是问我有什么想问的，问我觉得他对我的印象怎么样(我嘞个去，这个绕啊)，好在他跟我说挺好的。</p>
<p>第二天晚上我见的导师就是我现在的导师，门外等了二十多位同学，我和其他同学在等待的时候非常紧张，从科研楼610出来的每一位同学出来的时候，我都上去问感觉怎么样，老师关注什么方向，其实没有多大的帮助，可就是忍不住。那天问了我很多网络算法和项目上的问题，持续了四十多分钟，最后还补问了我个智力题：“给我一个已经弯的硬币怎么样才能公平的做决定。“当时没想出来，后来给发现冯诺依曼已经提出过方法了，把思路配上wiki网页都发给了老师。紧接着老师就打电话跟我聊了，从那时候开始半个月时间内和我聊天了很多次，因为考的一般为了保险起见想要调剂到别的组，得到了老师很多鼓励，一直留了下来直到进组。</p>
<p>后面的不多说了，多说无益，此处省略两万字...</p>
<h3 id="-">实习</h3>
<p>上学期一方面在实验室帮老师做网站，某企业的OA系统。另一方面希望可以拓展自己的知识面，于是在上学期9月份入学以后向百度投了一份简历，我从来没有在公司正式实习过，这次是第一次，投简历的过程也是一波三折。</p>
<p><strong>去向：</strong></p>
<ol>
<li>虽然投简历前的一段时间主要在用php，但是我也知道百度主要是在搜索和深度学习方面更牛一些，加上自己毕设做的是c相关的，在<a href="http://bbs.byr.cn" target="_blank">bbs</a>上找了一个百度的实习信息，结果投了一个简历竟然石沉大海了，我就不想再投了，桑心的说。后来有一次同学来我吃饭，聊到这个事情，说去实习吧，锻炼锻炼自己还能买台电脑，要不然你就毕业再买吧。戳中死穴，想来有道理呀！哈哈</li>
<li>时间比较少，做点和实验室有关的技术工作能减轻一些我的压力，于是我决定不认死理，就投了和php有关的简历。</li>
</ol>
<p>后面就是电话问问情况，安排面试时间，经过了四轮技术面试，一轮经理面试以后，顺利入职了。</p>
<p><strong>感想：</strong></p>
<p>实习了四个多月了，mentor对我挺好的，总体来说业务接触的比较多，经常处理一些导数据分析log之类的杂活，同时也会上手写网站，做业务代码和写服务。现在部门一直在推平台化，所以我们的架构也在改变，我也参与写了一些服务，整个开发模式和之前发生了很大的变化。企业级的服务和架构，感觉做什么事情都很顺畅，别人的服务拿回来用很爽，深深的觉得平台化的思路是很好的，每个小组做的事情都可以为其他组的业务服务，使用非常灵活，我们重写了安全中心的网站和服务，下学期开学了，实验室要求研一同学入住，撑到<em>“安全中心2.0“</em>上线完成后很遗憾我也要说再见了。</p>
<p>说说这个学期不实习的好处吧：勉强撑过了一个学期但是也太忙了，百度的开发实习生做的事情太多了，太忙时间占用太多了。要做实验室的项目，要上课保证考试，还要实习，属于自己的时间几乎没有了。总结起来三个字：忙...忙...忙...很多计划也没有办法进行。</p>
<h6 id="-by-the-way-mac-happy-_-">（by the way，新mac到手，还是很happy的^_^）</h6>
<h3 id="-">计划</h3>
<p>下面说说我这个学期的计划吧，给2014年上学期的生活定下一个蓝图。</p>
<ol>
<li><strong>自然语言处理</strong>，本科毕设做的是爬虫，主要看larbin，其实做一个简单的爬虫还是很容易的，当时对中文分词产生了兴趣，只是没有时间去弄，有空的这个学期当然是不会放过这次机会的啦~</li>
<li>看一本书，没错，每个学期都至少看明白一本专业书籍，买了好多书，看不下来当然不是没时间简单就能搪塞过去的，没时间要挤时间，挤不出来时间就要“调整产业结构”了嘛，这次学期我选择的是<strong>编译原理</strong>，原来学过这个课，但是学的不是很认真，上学期学了学“形式语言与自动机”，正好借着这个机会好好的学一学编译原理，真的想有时间可以自己写一个代码格式化工具或者模板引擎或者markdown解释器。</li>
<li>这个学期目测还会做web相关的<strong>实验室项目</strong>，但是经过了一个学期在公司的锤炼，还是有一些进步的，上个学期时间太紧没有时间做优化，是要到动大手术的时候了。</li>
<li><strong>计算机语言</strong>上，希望可以有时间学习学习新的语言吧，python、ruby、nodejs或者..或者一门lisp的方言都好</li>
<li><strong>自然语言</strong>上，不卖关子了，其实就是学好英语啦，英语已经没有什么老本可以啃了，汗啊！不能再自甘堕落了，这个学期有两门英语课，此时下不了决心就是态度问题了。</li>
</ol>
<p>能想到的暂时就是这些东西，够我喝一壶了吧。</p>
<p>上半年针对这些我要记录下来自己的感想和收获，push自己往前进步吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="-">上学期总结和下学期规划一览</h2>
<h3 id="-">入学</h3>
<p>考研的分数不是太高，只能勉强过组线，所以提前不少时间就开始准备联系导师和准备复试了，基本上每个老师都发了简历，但是不是每个老师都回了。<del>感谢那些亲自回学生邮件并给出中肯建议的老师们，怀念方SIR回邮件的速度</del>
]]>
    
    </summary>
    
      <category term="personal" scheme="http://zhangxian.me/tags/personal/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://zhangxian.me/2014/02/23/hello-world/"/>
    <id>http://zhangxian.me/2014/02/23/hello-world/</id>
    <published>2014-02-23T09:13:11.000Z</published>
    <updated>2014-10-18T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近有点时间想来搞一下自己的博客，原来的博客在cnblogs上，基本上没兴趣写啊。wordpress太重了，随着github pages这样的机制越来越顺手，还是弄一个纯静态的博客吧，简单易用靠谱，简单调查一下，还是用hexo吧，使用部署很简单，插件也多。寝室的网络太差，看在不要钱的份儿上就不吐槽了，装个node下了半天，擦~</p>
<p>神奇的<em><code>hello world</code></em>闪亮登场，噹噹噹噹！</p>
<p>能用markdown写博客，舒服好多，赶紧用上Mou，神器就是神奇，写这段文字的时候激动的泪流满面啊！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近有点时间想来搞一下自己的博客，原来的博客在cnblogs上，基本上没兴趣写啊。wordpress太重了，随着github pages这样的机制越来越顺手，还是弄一个纯静态的博客吧，简单易用靠谱，简单调查一下，还是用hexo吧，使用部署很简单，插件也多。寝室的网络太差，看]]>
    </summary>
    
  </entry>
  
</feed>
